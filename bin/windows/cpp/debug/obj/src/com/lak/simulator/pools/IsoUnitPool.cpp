// Generated by Haxe 3.4.0
#include <hxcpp.h>

#ifndef INCLUDED_com_lak_entities_IsoObject
#include <com/lak/entities/IsoObject.h>
#endif
#ifndef INCLUDED_com_lak_entities_IsoUnit
#include <com/lak/entities/IsoUnit.h>
#endif
#ifndef INCLUDED_com_lak_simulator_pools_IsoUnitPool
#include <com/lak/simulator/pools/IsoUnitPool.h>
#endif
#ifndef INCLUDED_openfl_display_DisplayObject
#include <openfl/display/DisplayObject.h>
#endif
#ifndef INCLUDED_openfl_display_DisplayObjectContainer
#include <openfl/display/DisplayObjectContainer.h>
#endif
#ifndef INCLUDED_openfl_display_IBitmapDrawable
#include <openfl/display/IBitmapDrawable.h>
#endif
#ifndef INCLUDED_openfl_display_InteractiveObject
#include <openfl/display/InteractiveObject.h>
#endif
#ifndef INCLUDED_openfl_display_Sprite
#include <openfl/display/Sprite.h>
#endif
#ifndef INCLUDED_openfl_events_EventDispatcher
#include <openfl/events/EventDispatcher.h>
#endif
#ifndef INCLUDED_openfl_events_IEventDispatcher
#include <openfl/events/IEventDispatcher.h>
#endif

HX_LOCAL_STACK_FRAME(_hx_pos_6692e5cb122a5655_18_initialize,"com.lak.simulator.pools.IsoUnitPool","initialize",0x96a1ce9f,"com.lak.simulator.pools.IsoUnitPool.initialize","com/lak/simulator/pools/IsoUnitPool.hx",18,0x6280efa3)
HX_LOCAL_STACK_FRAME(_hx_pos_6692e5cb122a5655_29_getEntity,"com.lak.simulator.pools.IsoUnitPool","getEntity",0x49f55dea,"com.lak.simulator.pools.IsoUnitPool.getEntity","com/lak/simulator/pools/IsoUnitPool.hx",29,0x6280efa3)
HX_LOCAL_STACK_FRAME(_hx_pos_6692e5cb122a5655_43_returnEntity,"com.lak.simulator.pools.IsoUnitPool","returnEntity",0x20369f02,"com.lak.simulator.pools.IsoUnitPool.returnEntity","com/lak/simulator/pools/IsoUnitPool.hx",43,0x6280efa3)
namespace com{
namespace lak{
namespace simulator{
namespace pools{

void IsoUnitPool_obj::__construct() { }

Dynamic IsoUnitPool_obj::__CreateEmpty() { return new IsoUnitPool_obj; }

void *IsoUnitPool_obj::_hx_vtable = 0;

Dynamic IsoUnitPool_obj::__Create(hx::DynamicArray inArgs)
{
	hx::ObjectPtr< IsoUnitPool_obj > _hx_result = new IsoUnitPool_obj();
	_hx_result->__construct();
	return _hx_result;
}

bool IsoUnitPool_obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x6358097d;
}

int IsoUnitPool_obj::MAX_VALUE;

int IsoUnitPool_obj::GROWTH_VALUE;

int IsoUnitPool_obj::counter;

::Array< ::Dynamic> IsoUnitPool_obj::pool;

 ::com::lak::entities::IsoUnit IsoUnitPool_obj::currentEntity;

void IsoUnitPool_obj::initialize(int maxPoolSize,int growthValue){
            	HX_GC_STACKFRAME(&_hx_pos_6692e5cb122a5655_18_initialize)
HXLINE(  19)		::com::lak::simulator::pools::IsoUnitPool_obj::MAX_VALUE = maxPoolSize;
HXLINE(  20)		::com::lak::simulator::pools::IsoUnitPool_obj::GROWTH_VALUE = growthValue;
HXLINE(  21)		::com::lak::simulator::pools::IsoUnitPool_obj::counter = maxPoolSize;
HXLINE(  23)		int i = maxPoolSize;
HXLINE(  25)		::com::lak::simulator::pools::IsoUnitPool_obj::pool = ::Array_obj< ::Dynamic>::__new();
HXLINE(  26)		while(true){
HXLINE(  26)			i = (i - (int)1);
HXDLIN(  26)			if (!((i > (int)-1))) {
HXLINE(  26)				goto _hx_goto_0;
            			}
HXDLIN(  26)			::Array< ::Dynamic> _hx_tmp = ::com::lak::simulator::pools::IsoUnitPool_obj::pool;
HXDLIN(  26)			_hx_tmp[i] =  ::com::lak::entities::IsoUnit_obj::__alloc( HX_CTX );
            		}
            		_hx_goto_0:;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(IsoUnitPool_obj,initialize,(void))

 ::com::lak::entities::IsoUnit IsoUnitPool_obj::getEntity(){
            	HX_GC_STACKFRAME(&_hx_pos_6692e5cb122a5655_29_getEntity)
HXLINE(  30)		if ((::com::lak::simulator::pools::IsoUnitPool_obj::counter > (int)0)) {
HXLINE(  31)			::Array< ::Dynamic> _hx_tmp = ::com::lak::simulator::pools::IsoUnitPool_obj::pool;
HXDLIN(  31)			return (::com::lak::simulator::pools::IsoUnitPool_obj::currentEntity = _hx_tmp->__get(--::com::lak::simulator::pools::IsoUnitPool_obj::counter).StaticCast<  ::com::lak::entities::IsoUnit >());
            		}
HXLINE(  33)		int i = ::com::lak::simulator::pools::IsoUnitPool_obj::GROWTH_VALUE;
HXLINE(  34)		while(true){
HXLINE(  34)			i = (i - (int)1);
HXDLIN(  34)			if (!((i > (int)-1))) {
HXLINE(  34)				goto _hx_goto_2;
            			}
HXLINE(  35)			::Array< ::Dynamic> _hx_tmp1 = ::com::lak::simulator::pools::IsoUnitPool_obj::pool;
HXDLIN(  35)			_hx_tmp1->unshift( ::com::lak::entities::IsoUnit_obj::__alloc( HX_CTX ));
            		}
            		_hx_goto_2:;
HXLINE(  36)		::com::lak::simulator::pools::IsoUnitPool_obj::counter = ::com::lak::simulator::pools::IsoUnitPool_obj::GROWTH_VALUE;
HXLINE(  37)		return ::com::lak::simulator::pools::IsoUnitPool_obj::getEntity();
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC0(IsoUnitPool_obj,getEntity,return )

void IsoUnitPool_obj::returnEntity( ::com::lak::entities::IsoUnit disposedUnit){
            	HX_STACKFRAME(&_hx_pos_6692e5cb122a5655_43_returnEntity)
HXLINE(  43)		::Array< ::Dynamic> _hx_tmp = ::com::lak::simulator::pools::IsoUnitPool_obj::pool;
HXDLIN(  43)		_hx_tmp[::com::lak::simulator::pools::IsoUnitPool_obj::counter++] = disposedUnit;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(IsoUnitPool_obj,returnEntity,(void))


IsoUnitPool_obj::IsoUnitPool_obj()
{
}

bool IsoUnitPool_obj::__GetStatic(const ::String &inName, Dynamic &outValue, hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 4:
		if (HX_FIELD_EQ(inName,"pool") ) { outValue = pool; return true; }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"counter") ) { outValue = counter; return true; }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"MAX_VALUE") ) { outValue = MAX_VALUE; return true; }
		if (HX_FIELD_EQ(inName,"getEntity") ) { outValue = getEntity_dyn(); return true; }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"initialize") ) { outValue = initialize_dyn(); return true; }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"GROWTH_VALUE") ) { outValue = GROWTH_VALUE; return true; }
		if (HX_FIELD_EQ(inName,"returnEntity") ) { outValue = returnEntity_dyn(); return true; }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"currentEntity") ) { outValue = currentEntity; return true; }
	}
	return false;
}

bool IsoUnitPool_obj::__SetStatic(const ::String &inName,Dynamic &ioValue,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 4:
		if (HX_FIELD_EQ(inName,"pool") ) { pool=ioValue.Cast< ::Array< ::Dynamic> >(); return true; }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"counter") ) { counter=ioValue.Cast< int >(); return true; }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"MAX_VALUE") ) { MAX_VALUE=ioValue.Cast< int >(); return true; }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"GROWTH_VALUE") ) { GROWTH_VALUE=ioValue.Cast< int >(); return true; }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"currentEntity") ) { currentEntity=ioValue.Cast<  ::com::lak::entities::IsoUnit >(); return true; }
	}
	return false;
}

#if HXCPP_SCRIPTABLE
static hx::StorageInfo *IsoUnitPool_obj_sMemberStorageInfo = 0;
static hx::StaticInfo IsoUnitPool_obj_sStaticStorageInfo[] = {
	{hx::fsInt,(void *) &IsoUnitPool_obj::MAX_VALUE,HX_HCSTRING("MAX_VALUE","\x16","\x60","\x5a","\xef")},
	{hx::fsInt,(void *) &IsoUnitPool_obj::GROWTH_VALUE,HX_HCSTRING("GROWTH_VALUE","\x19","\x46","\x80","\xac")},
	{hx::fsInt,(void *) &IsoUnitPool_obj::counter,HX_HCSTRING("counter","\xfc","\xae","\x59","\x1d")},
	{hx::fsObject /*Array< ::Dynamic >*/ ,(void *) &IsoUnitPool_obj::pool,HX_HCSTRING("pool","\xdc","\x80","\x5c","\x4a")},
	{hx::fsObject /*::com::lak::entities::IsoUnit*/ ,(void *) &IsoUnitPool_obj::currentEntity,HX_HCSTRING("currentEntity","\x3c","\x94","\x78","\xe8")},
	{ hx::fsUnknown, 0, null()}
};
#endif

static void IsoUnitPool_obj_sMarkStatics(HX_MARK_PARAMS) {
	HX_MARK_MEMBER_NAME(IsoUnitPool_obj::__mClass,"__mClass");
	HX_MARK_MEMBER_NAME(IsoUnitPool_obj::MAX_VALUE,"MAX_VALUE");
	HX_MARK_MEMBER_NAME(IsoUnitPool_obj::GROWTH_VALUE,"GROWTH_VALUE");
	HX_MARK_MEMBER_NAME(IsoUnitPool_obj::counter,"counter");
	HX_MARK_MEMBER_NAME(IsoUnitPool_obj::pool,"pool");
	HX_MARK_MEMBER_NAME(IsoUnitPool_obj::currentEntity,"currentEntity");
};

#ifdef HXCPP_VISIT_ALLOCS
static void IsoUnitPool_obj_sVisitStatics(HX_VISIT_PARAMS) {
	HX_VISIT_MEMBER_NAME(IsoUnitPool_obj::__mClass,"__mClass");
	HX_VISIT_MEMBER_NAME(IsoUnitPool_obj::MAX_VALUE,"MAX_VALUE");
	HX_VISIT_MEMBER_NAME(IsoUnitPool_obj::GROWTH_VALUE,"GROWTH_VALUE");
	HX_VISIT_MEMBER_NAME(IsoUnitPool_obj::counter,"counter");
	HX_VISIT_MEMBER_NAME(IsoUnitPool_obj::pool,"pool");
	HX_VISIT_MEMBER_NAME(IsoUnitPool_obj::currentEntity,"currentEntity");
};

#endif

hx::Class IsoUnitPool_obj::__mClass;

static ::String IsoUnitPool_obj_sStaticFields[] = {
	HX_HCSTRING("MAX_VALUE","\x16","\x60","\x5a","\xef"),
	HX_HCSTRING("GROWTH_VALUE","\x19","\x46","\x80","\xac"),
	HX_HCSTRING("counter","\xfc","\xae","\x59","\x1d"),
	HX_HCSTRING("pool","\xdc","\x80","\x5c","\x4a"),
	HX_HCSTRING("currentEntity","\x3c","\x94","\x78","\xe8"),
	HX_HCSTRING("initialize","\x50","\x31","\xbb","\xec"),
	HX_HCSTRING("getEntity","\x59","\x9c","\x72","\x81"),
	HX_HCSTRING("returnEntity","\xf3","\xcf","\x72","\x39"),
	::String(null())
};

void IsoUnitPool_obj::__register()
{
	hx::Object *dummy = new IsoUnitPool_obj;
	IsoUnitPool_obj::_hx_vtable = *(void **)dummy;
	hx::Static(__mClass) = new hx::Class_obj();
	__mClass->mName = HX_HCSTRING("com.lak.simulator.pools.IsoUnitPool","\xbf","\xb2","\x9c","\x53");
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &IsoUnitPool_obj::__GetStatic;
	__mClass->mSetStaticField = &IsoUnitPool_obj::__SetStatic;
	__mClass->mMarkFunc = IsoUnitPool_obj_sMarkStatics;
	__mClass->mStatics = hx::Class_obj::dupFunctions(IsoUnitPool_obj_sStaticFields);
	__mClass->mMembers = hx::Class_obj::dupFunctions(0 /* sMemberFields */);
	__mClass->mCanCast = hx::TCanCast< IsoUnitPool_obj >;
#ifdef HXCPP_VISIT_ALLOCS
	__mClass->mVisitFunc = IsoUnitPool_obj_sVisitStatics;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = IsoUnitPool_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = IsoUnitPool_obj_sStaticStorageInfo;
#endif
	hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace com
} // end namespace lak
} // end namespace simulator
} // end namespace pools
