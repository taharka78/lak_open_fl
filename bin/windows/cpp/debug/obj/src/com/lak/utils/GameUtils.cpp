// Generated by Haxe 3.4.0
#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_com_lak_IsoWorld
#include <com/lak/IsoWorld.h>
#endif
#ifndef INCLUDED_com_lak_utils_GameUtils
#include <com/lak/utils/GameUtils.h>
#endif
#ifndef INCLUDED_com_lak_utils_IsoUtils
#include <com/lak/utils/IsoUtils.h>
#endif
#ifndef INCLUDED_haxe_Log
#include <haxe/Log.h>
#endif
#ifndef INCLUDED_openfl_display_DisplayObject
#include <openfl/display/DisplayObject.h>
#endif
#ifndef INCLUDED_openfl_display_DisplayObjectContainer
#include <openfl/display/DisplayObjectContainer.h>
#endif
#ifndef INCLUDED_openfl_display_IBitmapDrawable
#include <openfl/display/IBitmapDrawable.h>
#endif
#ifndef INCLUDED_openfl_display_InteractiveObject
#include <openfl/display/InteractiveObject.h>
#endif
#ifndef INCLUDED_openfl_display_Sprite
#include <openfl/display/Sprite.h>
#endif
#ifndef INCLUDED_openfl_events_EventDispatcher
#include <openfl/events/EventDispatcher.h>
#endif
#ifndef INCLUDED_openfl_events_IEventDispatcher
#include <openfl/events/IEventDispatcher.h>
#endif
#ifndef INCLUDED_openfl_geom_Point
#include <openfl/geom/Point.h>
#endif

HX_LOCAL_STACK_FRAME(_hx_pos_bb049c6bb5b45885_13_getAngleBetweenPt,"com.lak.utils.GameUtils","getAngleBetweenPt",0x3bcc299e,"com.lak.utils.GameUtils.getAngleBetweenPt","com/lak/utils/GameUtils.hx",13,0xbd51a1e4)
HX_LOCAL_STACK_FRAME(_hx_pos_bb049c6bb5b45885_21_sortByF,"com.lak.utils.GameUtils","sortByF",0x480e93e0,"com.lak.utils.GameUtils.sortByF","com/lak/utils/GameUtils.hx",21,0xbd51a1e4)
HX_LOCAL_STACK_FRAME(_hx_pos_bb049c6bb5b45885_34_random,"com.lak.utils.GameUtils","random",0x463b0ad4,"com.lak.utils.GameUtils.random","com/lak/utils/GameUtils.hx",34,0xbd51a1e4)
HX_LOCAL_STACK_FRAME(_hx_pos_bb049c6bb5b45885_37_dx,"com.lak.utils.GameUtils","dx",0xf25143e5,"com.lak.utils.GameUtils.dx","com/lak/utils/GameUtils.hx",37,0xbd51a1e4)
HX_LOCAL_STACK_FRAME(_hx_pos_bb049c6bb5b45885_43_dy,"com.lak.utils.GameUtils","dy",0xf25143e6,"com.lak.utils.GameUtils.dy","com/lak/utils/GameUtils.hx",43,0xbd51a1e4)
HX_LOCAL_STACK_FRAME(_hx_pos_bb049c6bb5b45885_48_distanceBetweenPt,"com.lak.utils.GameUtils","distanceBetweenPt",0xbce12ec6,"com.lak.utils.GameUtils.distanceBetweenPt","com/lak/utils/GameUtils.hx",48,0xbd51a1e4)
HX_LOCAL_STACK_FRAME(_hx_pos_bb049c6bb5b45885_57_toGridCoord,"com.lak.utils.GameUtils","toGridCoord",0x67c8faa3,"com.lak.utils.GameUtils.toGridCoord","com/lak/utils/GameUtils.hx",57,0xbd51a1e4)
HX_LOCAL_STACK_FRAME(_hx_pos_bb049c6bb5b45885_66_to2DDimension,"com.lak.utils.GameUtils","to2DDimension",0x69a98ee8,"com.lak.utils.GameUtils.to2DDimension","com/lak/utils/GameUtils.hx",66,0xbd51a1e4)
namespace com{
namespace lak{
namespace utils{

void GameUtils_obj::__construct() { }

Dynamic GameUtils_obj::__CreateEmpty() { return new GameUtils_obj; }

void *GameUtils_obj::_hx_vtable = 0;

Dynamic GameUtils_obj::__Create(hx::DynamicArray inArgs)
{
	hx::ObjectPtr< GameUtils_obj > _hx_result = new GameUtils_obj();
	_hx_result->__construct();
	return _hx_result;
}

bool GameUtils_obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x01f7dfeb;
}

Float GameUtils_obj::getAngleBetweenPt( ::openfl::geom::Point pt1, ::openfl::geom::Point pt2){
            	HX_STACKFRAME(&_hx_pos_bb049c6bb5b45885_13_getAngleBetweenPt)
HXLINE(  14)		Float dx = (pt2->x - pt1->x);
HXLINE(  15)		Float dy = (pt2->y - pt1->y);
HXLINE(  16)		Float angle = ::Math_obj::atan2(dy,dx);
HXDLIN(  16)		Float angle1 = (angle * ((Float)(int)180 / (Float)::Math_obj::PI));
HXLINE(  17)		if ((angle1 < (int)0)) {
HXLINE(  17)			angle1 = (angle1 + (int)360);
            		}
HXLINE(  18)		return angle1;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(GameUtils_obj,getAngleBetweenPt,return )

int GameUtils_obj::sortByF( ::Dynamic a, ::Dynamic b){
            	HX_STACKFRAME(&_hx_pos_bb049c6bb5b45885_21_sortByF)
HXLINE(  22)		if (hx::IsLess(  ::Dynamic(a->__Field(HX_("f",66,00,00,00),hx::paccDynamic)), ::Dynamic(b->__Field(HX_("f",66,00,00,00),hx::paccDynamic)) )) {
HXLINE(  22)			return (int)-1;
            		}
HXLINE(  23)		if (hx::IsGreater(  ::Dynamic(a->__Field(HX_("f",66,00,00,00),hx::paccDynamic)), ::Dynamic(b->__Field(HX_("f",66,00,00,00),hx::paccDynamic)) )) {
HXLINE(  23)			return (int)1;
            		}
HXLINE(  24)		return (int)0;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(GameUtils_obj,sortByF,return )

int GameUtils_obj::random(int min,int max){
            	HX_STACKFRAME(&_hx_pos_bb049c6bb5b45885_34_random)
HXLINE(  34)		Float _hx_tmp = ::Math_obj::random();
HXDLIN(  34)		return ::Math_obj::floor((min + (_hx_tmp * (max - min))));
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(GameUtils_obj,random,return )

Float GameUtils_obj::dx( ::openfl::geom::Point objectA, ::openfl::geom::Point objectB){
            	HX_STACKFRAME(&_hx_pos_bb049c6bb5b45885_37_dx)
HXLINE(  38)		Float dx = ::Math_obj::abs((objectA->x - objectB->x));
HXLINE(  39)		return dx;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(GameUtils_obj,dx,return )

Float GameUtils_obj::dy( ::openfl::geom::Point objectA, ::openfl::geom::Point objectB){
            	HX_STACKFRAME(&_hx_pos_bb049c6bb5b45885_43_dy)
HXLINE(  44)		Float dy = ::Math_obj::abs((objectA->y - objectB->y));
HXLINE(  45)		return dy;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(GameUtils_obj,dy,return )

Float GameUtils_obj::distanceBetweenPt( ::openfl::geom::Point pt1, ::openfl::geom::Point pt2){
            	HX_STACKFRAME(&_hx_pos_bb049c6bb5b45885_48_distanceBetweenPt)
HXLINE(  48)		Float _hx_tmp = ::Math_obj::pow((pt1->x - pt2->x),(int)2);
HXDLIN(  48)		return ::Math_obj::sqrt((_hx_tmp + ::Math_obj::pow((pt1->y - pt2->y),(int)2)));
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(GameUtils_obj,distanceBetweenPt,return )

Float GameUtils_obj::toGridCoord(Float n1,Float factor){
            	HX_STACKFRAME(&_hx_pos_bb049c6bb5b45885_57_toGridCoord)
HXLINE(  57)		return (::Math_obj::round(((Float)n1 / (Float)factor)) * factor);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(GameUtils_obj,toGridCoord,return )

::cpp::VirtualArray GameUtils_obj::to2DDimension(::String str,::String partName,hx::Null< int >  __o_size){
int size = __o_size.Default(100);
            	HX_GC_STACKFRAME(&_hx_pos_bb049c6bb5b45885_66_to2DDimension)
HXLINE(  67)		::Array< ::String > ar = str.split(HX_(",",2c,00,00,00));
HXLINE(  68)		::cpp::VirtualArray dArray = ::Array_obj< ::Dynamic>::__new();
HXLINE(  69)		int indexX = (int)0;
HXLINE(  70)		int indexY = (int)0;
HXLINE(  72)		::String str1 = partName.split(HX_("_",5f,00,00,00))->__get((int)1).split(HX_(".",2e,00,00,00))->__get((int)0);
HXLINE(  74)		int offsetX = (::Std_obj::parseInt(str1.split(HX_("-",2d,00,00,00))->__get((int)0)) * (int)100);
HXLINE(  75)		int offsetY = (::Std_obj::parseInt(str1.split(HX_("-",2d,00,00,00))->__get((int)1)) * (int)100);
HXLINE(  76)		::haxe::Log_obj::trace(str1, ::Dynamic(hx::Anon_obj::Create(5)
            			->setFixed(0,HX_("className",a3,92,3d,dc),HX_("com.lak.utils.GameUtils",7d,07,f0,f6))
            			->setFixed(1,HX_("customParams",d7,51,18,ed),::cpp::VirtualArray_obj::__new(2)->init(0,offsetX)->init(1,offsetY))
            			->setFixed(2,HX_("methodName",cc,19,0f,12),HX_("to2DDimension",99,4b,59,93))
            			->setFixed(3,HX_("fileName",e7,5a,43,62),HX_("GameUtils.hx",5f,8b,b1,75))
            			->setFixed(4,HX_("lineNumber",dd,81,22,76),(int)76)));
HXLINE(  77)		{
HXLINE(  77)			int _g1 = (int)0;
HXDLIN(  77)			int _g = ar->length;
HXDLIN(  77)			while((_g1 < _g)){
HXLINE(  77)				_g1 = (_g1 + (int)1);
HXDLIN(  77)				int i = (_g1 - (int)1);
HXLINE(  78)				indexX = ::Math_obj::floor(hx::Mod(i,(int)100));
HXLINE(  79)				indexY = ::Math_obj::floor(((Float)i / (Float)(int)100));
HXLINE(  80)				if (hx::IsNull( dArray->__get(indexX) )) {
HXLINE(  80)					dArray->set(indexX,::cpp::VirtualArray_obj::__new());
            				}
HXLINE(  81)				::String ar1 = ar->__get(i);
HXDLIN(  81)				dArray->__get(indexX)->__SetItem(indexY, ::Dynamic(hx::Anon_obj::Create(6)
            					->setFixed(0,HX_("ndType",10,d2,35,c7),ar1)
            					->setFixed(1,HX_("position",a9,a0,fa,ca),::com::lak::utils::IsoUtils_obj::mapTilePosition( ::openfl::geom::Point_obj::__alloc( HX_CTX ,(indexX + offsetX),(indexY + offsetY)),::com::lak::IsoWorld_obj::instance->tileW,::com::lak::IsoWorld_obj::instance->tileH))
            					->setFixed(2,HX_("f",66,00,00,00),(int)0)
            					->setFixed(3,HX_("g",67,00,00,00),(int)0)
            					->setFixed(4,HX_("h",68,00,00,00),(int)0)
            					->setFixed(5,HX_("direction",3f,62,40,10),HX_("",00,00,00,00))));
            			}
            		}
HXLINE(  83)		return dArray;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC3(GameUtils_obj,to2DDimension,return )


GameUtils_obj::GameUtils_obj()
{
}

bool GameUtils_obj::__GetStatic(const ::String &inName, Dynamic &outValue, hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 2:
		if (HX_FIELD_EQ(inName,"dx") ) { outValue = dx_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"dy") ) { outValue = dy_dyn(); return true; }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"random") ) { outValue = random_dyn(); return true; }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"sortByF") ) { outValue = sortByF_dyn(); return true; }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"toGridCoord") ) { outValue = toGridCoord_dyn(); return true; }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"to2DDimension") ) { outValue = to2DDimension_dyn(); return true; }
		break;
	case 17:
		if (HX_FIELD_EQ(inName,"getAngleBetweenPt") ) { outValue = getAngleBetweenPt_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"distanceBetweenPt") ) { outValue = distanceBetweenPt_dyn(); return true; }
	}
	return false;
}

#if HXCPP_SCRIPTABLE
static hx::StorageInfo *GameUtils_obj_sMemberStorageInfo = 0;
static hx::StaticInfo *GameUtils_obj_sStaticStorageInfo = 0;
#endif

static void GameUtils_obj_sMarkStatics(HX_MARK_PARAMS) {
	HX_MARK_MEMBER_NAME(GameUtils_obj::__mClass,"__mClass");
};

#ifdef HXCPP_VISIT_ALLOCS
static void GameUtils_obj_sVisitStatics(HX_VISIT_PARAMS) {
	HX_VISIT_MEMBER_NAME(GameUtils_obj::__mClass,"__mClass");
};

#endif

hx::Class GameUtils_obj::__mClass;

static ::String GameUtils_obj_sStaticFields[] = {
	HX_HCSTRING("getAngleBetweenPt","\xcf","\x92","\xf6","\xa7"),
	HX_HCSTRING("sortByF","\xd1","\xc5","\x4e","\x00"),
	HX_HCSTRING("random","\x03","\x22","\x8f","\xb7"),
	HX_HCSTRING("dx","\x94","\x57","\x00","\x00"),
	HX_HCSTRING("dy","\x95","\x57","\x00","\x00"),
	HX_HCSTRING("distanceBetweenPt","\xf7","\x97","\x0b","\x29"),
	HX_HCSTRING("toGridCoord","\x14","\x79","\x07","\xa6"),
	HX_HCSTRING("to2DDimension","\x99","\x4b","\x59","\x93"),
	::String(null())
};

void GameUtils_obj::__register()
{
	hx::Object *dummy = new GameUtils_obj;
	GameUtils_obj::_hx_vtable = *(void **)dummy;
	hx::Static(__mClass) = new hx::Class_obj();
	__mClass->mName = HX_HCSTRING("com.lak.utils.GameUtils","\x7d","\x07","\xf0","\xf6");
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &GameUtils_obj::__GetStatic;
	__mClass->mSetStaticField = &hx::Class_obj::SetNoStaticField;
	__mClass->mMarkFunc = GameUtils_obj_sMarkStatics;
	__mClass->mStatics = hx::Class_obj::dupFunctions(GameUtils_obj_sStaticFields);
	__mClass->mMembers = hx::Class_obj::dupFunctions(0 /* sMemberFields */);
	__mClass->mCanCast = hx::TCanCast< GameUtils_obj >;
#ifdef HXCPP_VISIT_ALLOCS
	__mClass->mVisitFunc = GameUtils_obj_sVisitStatics;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = GameUtils_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = GameUtils_obj_sStaticStorageInfo;
#endif
	hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace com
} // end namespace lak
} // end namespace utils
